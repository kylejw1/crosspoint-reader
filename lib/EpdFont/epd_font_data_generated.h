// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EPDFONTDATA_EPD_H_
#define FLATBUFFERS_GENERATED_EPDFONTDATA_EPD_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace epd {

struct EpdGlyph;
struct EpdGlyphBuilder;

struct EpdUnicodeInterval;

struct EpdFontData;
struct EpdFontDataBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EpdUnicodeInterval FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t first_;
  uint32_t last_;
  uint32_t offset_;

 public:
  EpdUnicodeInterval()
      : first_(0),
        last_(0),
        offset_(0) {
  }
  EpdUnicodeInterval(uint32_t _first, uint32_t _last, uint32_t _offset)
      : first_(::flatbuffers::EndianScalar(_first)),
        last_(::flatbuffers::EndianScalar(_last)),
        offset_(::flatbuffers::EndianScalar(_offset)) {
  }
  uint32_t first() const {
    return ::flatbuffers::EndianScalar(first_);
  }
  uint32_t last() const {
    return ::flatbuffers::EndianScalar(last_);
  }
  uint32_t offset() const {
    return ::flatbuffers::EndianScalar(offset_);
  }
};
FLATBUFFERS_STRUCT_END(EpdUnicodeInterval, 12);

struct EpdGlyph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EpdGlyphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_ADVANCE_X = 8,
    VT_LEFT = 10,
    VT_TOP = 12,
    VT_DATA_LENGTH = 14,
    VT_DATA_OFFSET = 16
  };
  uint8_t width() const {
    return GetField<uint8_t>(VT_WIDTH, 0);
  }
  uint8_t height() const {
    return GetField<uint8_t>(VT_HEIGHT, 0);
  }
  uint8_t advance_x() const {
    return GetField<uint8_t>(VT_ADVANCE_X, 0);
  }
  int16_t left() const {
    return GetField<int16_t>(VT_LEFT, 0);
  }
  int16_t top() const {
    return GetField<int16_t>(VT_TOP, 0);
  }
  uint16_t data_length() const {
    return GetField<uint16_t>(VT_DATA_LENGTH, 0);
  }
  uint32_t data_offset() const {
    return GetField<uint32_t>(VT_DATA_OFFSET, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WIDTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_HEIGHT, 1) &&
           VerifyField<uint8_t>(verifier, VT_ADVANCE_X, 1) &&
           VerifyField<int16_t>(verifier, VT_LEFT, 2) &&
           VerifyField<int16_t>(verifier, VT_TOP, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA_LENGTH, 2) &&
           VerifyField<uint32_t>(verifier, VT_DATA_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct EpdGlyphBuilder {
  typedef EpdGlyph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_width(uint8_t width) {
    fbb_.AddElement<uint8_t>(EpdGlyph::VT_WIDTH, width, 0);
  }
  void add_height(uint8_t height) {
    fbb_.AddElement<uint8_t>(EpdGlyph::VT_HEIGHT, height, 0);
  }
  void add_advance_x(uint8_t advance_x) {
    fbb_.AddElement<uint8_t>(EpdGlyph::VT_ADVANCE_X, advance_x, 0);
  }
  void add_left(int16_t left) {
    fbb_.AddElement<int16_t>(EpdGlyph::VT_LEFT, left, 0);
  }
  void add_top(int16_t top) {
    fbb_.AddElement<int16_t>(EpdGlyph::VT_TOP, top, 0);
  }
  void add_data_length(uint16_t data_length) {
    fbb_.AddElement<uint16_t>(EpdGlyph::VT_DATA_LENGTH, data_length, 0);
  }
  void add_data_offset(uint32_t data_offset) {
    fbb_.AddElement<uint32_t>(EpdGlyph::VT_DATA_OFFSET, data_offset, 0);
  }
  explicit EpdGlyphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EpdGlyph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EpdGlyph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EpdGlyph> CreateEpdGlyph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t width = 0,
    uint8_t height = 0,
    uint8_t advance_x = 0,
    int16_t left = 0,
    int16_t top = 0,
    uint16_t data_length = 0,
    uint32_t data_offset = 0) {
  EpdGlyphBuilder builder_(_fbb);
  builder_.add_data_offset(data_offset);
  builder_.add_data_length(data_length);
  builder_.add_top(top);
  builder_.add_left(left);
  builder_.add_advance_x(advance_x);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct EpdFontData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EpdFontDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITMAP = 4,
    VT_GLYPH = 6,
    VT_INTERVALS = 8,
    VT_ADVANCE_Y = 10,
    VT_ASCENDER = 12,
    VT_DESCENDER = 14,
    VT_IS_2BIT = 16
  };
  const ::flatbuffers::Vector<uint8_t> *bitmap() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BITMAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<epd::EpdGlyph>> *glyph() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<epd::EpdGlyph>> *>(VT_GLYPH);
  }
  const ::flatbuffers::Vector<const epd::EpdUnicodeInterval *> *intervals() const {
    return GetPointer<const ::flatbuffers::Vector<const epd::EpdUnicodeInterval *> *>(VT_INTERVALS);
  }
  uint8_t advance_y() const {
    return GetField<uint8_t>(VT_ADVANCE_Y, 0);
  }
  int32_t ascender() const {
    return GetField<int32_t>(VT_ASCENDER, 0);
  }
  int32_t descender() const {
    return GetField<int32_t>(VT_DESCENDER, 0);
  }
  bool is_2bit() const {
    return GetField<uint8_t>(VT_IS_2BIT, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BITMAP) &&
           verifier.VerifyVector(bitmap()) &&
           VerifyOffset(verifier, VT_GLYPH) &&
           verifier.VerifyVector(glyph()) &&
           verifier.VerifyVectorOfTables(glyph()) &&
           VerifyOffset(verifier, VT_INTERVALS) &&
           verifier.VerifyVector(intervals()) &&
           VerifyField<uint8_t>(verifier, VT_ADVANCE_Y, 1) &&
           VerifyField<int32_t>(verifier, VT_ASCENDER, 4) &&
           VerifyField<int32_t>(verifier, VT_DESCENDER, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_2BIT, 1) &&
           verifier.EndTable();
  }
};

struct EpdFontDataBuilder {
  typedef EpdFontData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bitmap(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bitmap) {
    fbb_.AddOffset(EpdFontData::VT_BITMAP, bitmap);
  }
  void add_glyph(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<epd::EpdGlyph>>> glyph) {
    fbb_.AddOffset(EpdFontData::VT_GLYPH, glyph);
  }
  void add_intervals(::flatbuffers::Offset<::flatbuffers::Vector<const epd::EpdUnicodeInterval *>> intervals) {
    fbb_.AddOffset(EpdFontData::VT_INTERVALS, intervals);
  }
  void add_advance_y(uint8_t advance_y) {
    fbb_.AddElement<uint8_t>(EpdFontData::VT_ADVANCE_Y, advance_y, 0);
  }
  void add_ascender(int32_t ascender) {
    fbb_.AddElement<int32_t>(EpdFontData::VT_ASCENDER, ascender, 0);
  }
  void add_descender(int32_t descender) {
    fbb_.AddElement<int32_t>(EpdFontData::VT_DESCENDER, descender, 0);
  }
  void add_is_2bit(bool is_2bit) {
    fbb_.AddElement<uint8_t>(EpdFontData::VT_IS_2BIT, static_cast<uint8_t>(is_2bit), 0);
  }
  explicit EpdFontDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EpdFontData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EpdFontData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EpdFontData> CreateEpdFontData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bitmap = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<epd::EpdGlyph>>> glyph = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const epd::EpdUnicodeInterval *>> intervals = 0,
    uint8_t advance_y = 0,
    int32_t ascender = 0,
    int32_t descender = 0,
    bool is_2bit = false) {
  EpdFontDataBuilder builder_(_fbb);
  builder_.add_descender(descender);
  builder_.add_ascender(ascender);
  builder_.add_intervals(intervals);
  builder_.add_glyph(glyph);
  builder_.add_bitmap(bitmap);
  builder_.add_is_2bit(is_2bit);
  builder_.add_advance_y(advance_y);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EpdFontData> CreateEpdFontDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bitmap = nullptr,
    const std::vector<::flatbuffers::Offset<epd::EpdGlyph>> *glyph = nullptr,
    const std::vector<epd::EpdUnicodeInterval> *intervals = nullptr,
    uint8_t advance_y = 0,
    int32_t ascender = 0,
    int32_t descender = 0,
    bool is_2bit = false) {
  auto bitmap__ = bitmap ? _fbb.CreateVector<uint8_t>(*bitmap) : 0;
  auto glyph__ = glyph ? _fbb.CreateVector<::flatbuffers::Offset<epd::EpdGlyph>>(*glyph) : 0;
  auto intervals__ = intervals ? _fbb.CreateVectorOfStructs<epd::EpdUnicodeInterval>(*intervals) : 0;
  return epd::CreateEpdFontData(
      _fbb,
      bitmap__,
      glyph__,
      intervals__,
      advance_y,
      ascender,
      descender,
      is_2bit);
}

inline const epd::EpdFontData *GetEpdFontData(const void *buf) {
  return ::flatbuffers::GetRoot<epd::EpdFontData>(buf);
}

inline const epd::EpdFontData *GetSizePrefixedEpdFontData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<epd::EpdFontData>(buf);
}

template <bool B = false>
inline bool VerifyEpdFontDataBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<epd::EpdFontData>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedEpdFontDataBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<epd::EpdFontData>(nullptr);
}

inline void FinishEpdFontDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<epd::EpdFontData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEpdFontDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<epd::EpdFontData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace epd

#endif  // FLATBUFFERS_GENERATED_EPDFONTDATA_EPD_H_
