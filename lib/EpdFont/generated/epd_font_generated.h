// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EPDFONT_EPD_H_
#define FLATBUFFERS_GENERATED_EPDFONT_EPD_H_

#include "flatbuffers/flatbuffers.h"

namespace epd {

struct EpdGlyph;

struct EpdUnicodeInterval;

struct EpdFont;
struct EpdFontBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EpdGlyph FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t width_;
  uint8_t height_;
  uint8_t advance_x_;
  int8_t padding0__;
  int16_t left_;
  int16_t top_;
  uint16_t data_length_;
  int16_t padding1__;
  uint32_t data_offset_;

 public:
  EpdGlyph()
      : width_(0),
        height_(0),
        advance_x_(0),
        padding0__(0),
        left_(0),
        top_(0),
        data_length_(0),
        padding1__(0),
        data_offset_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  EpdGlyph(uint8_t _width, uint8_t _height, uint8_t _advance_x, int16_t _left, int16_t _top, uint16_t _data_length, uint32_t _data_offset)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)),
        advance_x_(flatbuffers::EndianScalar(_advance_x)),
        padding0__(0),
        left_(flatbuffers::EndianScalar(_left)),
        top_(flatbuffers::EndianScalar(_top)),
        data_length_(flatbuffers::EndianScalar(_data_length)),
        padding1__(0),
        data_offset_(flatbuffers::EndianScalar(_data_offset)) {
  }
  uint8_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  uint8_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
  uint8_t advance_x() const {
    return flatbuffers::EndianScalar(advance_x_);
  }
  int16_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int16_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  uint16_t data_length() const {
    return flatbuffers::EndianScalar(data_length_);
  }
  uint32_t data_offset() const {
    return flatbuffers::EndianScalar(data_offset_);
  }
};
FLATBUFFERS_STRUCT_END(EpdGlyph, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EpdUnicodeInterval FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t first_;
  uint32_t last_;
  uint32_t offset_;

 public:
  EpdUnicodeInterval()
      : first_(0),
        last_(0),
        offset_(0) {
  }
  EpdUnicodeInterval(uint32_t _first, uint32_t _last, uint32_t _offset)
      : first_(flatbuffers::EndianScalar(_first)),
        last_(flatbuffers::EndianScalar(_last)),
        offset_(flatbuffers::EndianScalar(_offset)) {
  }
  uint32_t first() const {
    return flatbuffers::EndianScalar(first_);
  }
  uint32_t last() const {
    return flatbuffers::EndianScalar(last_);
  }
  uint32_t offset() const {
    return flatbuffers::EndianScalar(offset_);
  }
};
FLATBUFFERS_STRUCT_END(EpdUnicodeInterval, 12);

struct EpdFont FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EpdFontBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITMAP = 4,
    VT_GLYPH = 6,
    VT_INTERVALS = 8,
    VT_ADVANCE_Y = 10,
    VT_ASCENDER = 12,
    VT_DESCENDER = 14,
    VT_IS_2BIT = 16
  };
  const flatbuffers::Vector<uint8_t> *bitmap() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BITMAP);
  }
  const flatbuffers::Vector<const epd::EpdGlyph *> *glyph() const {
    return GetPointer<const flatbuffers::Vector<const epd::EpdGlyph *> *>(VT_GLYPH);
  }
  const flatbuffers::Vector<const epd::EpdUnicodeInterval *> *intervals() const {
    return GetPointer<const flatbuffers::Vector<const epd::EpdUnicodeInterval *> *>(VT_INTERVALS);
  }
  uint8_t advance_y() const {
    return GetField<uint8_t>(VT_ADVANCE_Y, 0);
  }
  int32_t ascender() const {
    return GetField<int32_t>(VT_ASCENDER, 0);
  }
  int32_t descender() const {
    return GetField<int32_t>(VT_DESCENDER, 0);
  }
  bool is_2bit() const {
    return GetField<uint8_t>(VT_IS_2BIT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BITMAP) &&
           verifier.VerifyVector(bitmap()) &&
           VerifyOffset(verifier, VT_GLYPH) &&
           verifier.VerifyVector(glyph()) &&
           VerifyOffset(verifier, VT_INTERVALS) &&
           verifier.VerifyVector(intervals()) &&
          //  VerifyField<uint8_t>(verifier, VT_ADVANCE_Y) &&
          //  VerifyField<int32_t>(verifier, VT_ASCENDER) &&
          //  VerifyField<int32_t>(verifier, VT_DESCENDER) &&
          //  VerifyField<uint8_t>(verifier, VT_IS_2BIT) &&
           verifier.EndTable();
  }
};

struct EpdFontBuilder {
  typedef EpdFont Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bitmap(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bitmap) {
    fbb_.AddOffset(EpdFont::VT_BITMAP, bitmap);
  }
  void add_glyph(flatbuffers::Offset<flatbuffers::Vector<const epd::EpdGlyph *>> glyph) {
    fbb_.AddOffset(EpdFont::VT_GLYPH, glyph);
  }
  void add_intervals(flatbuffers::Offset<flatbuffers::Vector<const epd::EpdUnicodeInterval *>> intervals) {
    fbb_.AddOffset(EpdFont::VT_INTERVALS, intervals);
  }
  void add_advance_y(uint8_t advance_y) {
    fbb_.AddElement<uint8_t>(EpdFont::VT_ADVANCE_Y, advance_y, 0);
  }
  void add_ascender(int32_t ascender) {
    fbb_.AddElement<int32_t>(EpdFont::VT_ASCENDER, ascender, 0);
  }
  void add_descender(int32_t descender) {
    fbb_.AddElement<int32_t>(EpdFont::VT_DESCENDER, descender, 0);
  }
  void add_is_2bit(bool is_2bit) {
    fbb_.AddElement<uint8_t>(EpdFont::VT_IS_2BIT, static_cast<uint8_t>(is_2bit), 0);
  }
  explicit EpdFontBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EpdFont> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EpdFont>(end);
    return o;
  }
};

inline flatbuffers::Offset<EpdFont> CreateEpdFont(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bitmap = 0,
    flatbuffers::Offset<flatbuffers::Vector<const epd::EpdGlyph *>> glyph = 0,
    flatbuffers::Offset<flatbuffers::Vector<const epd::EpdUnicodeInterval *>> intervals = 0,
    uint8_t advance_y = 0,
    int32_t ascender = 0,
    int32_t descender = 0,
    bool is_2bit = false) {
  EpdFontBuilder builder_(_fbb);
  builder_.add_descender(descender);
  builder_.add_ascender(ascender);
  builder_.add_intervals(intervals);
  builder_.add_glyph(glyph);
  builder_.add_bitmap(bitmap);
  builder_.add_is_2bit(is_2bit);
  builder_.add_advance_y(advance_y);
  return builder_.Finish();
}

inline flatbuffers::Offset<EpdFont> CreateEpdFontDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bitmap = nullptr,
    const std::vector<epd::EpdGlyph> *glyph = nullptr,
    const std::vector<epd::EpdUnicodeInterval> *intervals = nullptr,
    uint8_t advance_y = 0,
    int32_t ascender = 0,
    int32_t descender = 0,
    bool is_2bit = false) {
  auto bitmap__ = bitmap ? _fbb.CreateVector<uint8_t>(*bitmap) : 0;
  auto glyph__ = glyph ? _fbb.CreateVectorOfStructs<epd::EpdGlyph>(*glyph) : 0;
  auto intervals__ = intervals ? _fbb.CreateVectorOfStructs<epd::EpdUnicodeInterval>(*intervals) : 0;
  return epd::CreateEpdFont(
      _fbb,
      bitmap__,
      glyph__,
      intervals__,
      advance_y,
      ascender,
      descender,
      is_2bit);
}

inline const epd::EpdFont *GetEpdFont(const void *buf) {
  return flatbuffers::GetRoot<epd::EpdFont>(buf);
}

inline const epd::EpdFont *GetSizePrefixedEpdFont(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<epd::EpdFont>(buf);
}

inline bool VerifyEpdFontBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<epd::EpdFont>(nullptr);
}

inline bool VerifySizePrefixedEpdFontBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<epd::EpdFont>(nullptr);
}

inline void FinishEpdFontBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<epd::EpdFont> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEpdFontBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<epd::EpdFont> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace epd

#endif  // FLATBUFFERS_GENERATED_EPDFONT_EPD_H_
